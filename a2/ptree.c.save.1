#include <stdio.h>
// Add your system includes here.
#include <string.h>
#include "ptree.h"

// Defining the constants described in ptree.h
const unsigned int MAX_PATH_LENGTH = 1024;

// If TEST is defined (see the Makefile), will look in the tests 
// directory for PIDs, instead of /proc.
#ifdef TEST
    const char *PROC_ROOT = "tests";
#else
    const char *PROC_ROOT = "/proc";
#endif


int generate_list(char * cmd_file , char * child_file, char * cmd_name, pid_t * children){
	int children_count = 0;
	File * proc_cmd = fopen(cmd_file,'r');
	File * proc_child = fopen(child_file,'r');
	cmd_file 
	
	
	
	
	return children_count;
}



/*
 * Creates a PTree rooted at the process pid. The root of the tree is
 * placed in root. The function returns 0 if the tree was created 
 * successfully and 1 if the tree could not be created or if at least
 * one PID was encountered that could not be found or was not an 
 * executing process.
 */
int generate_ptree(struct TreeNode **root, pid_t pid) {
    // Here's a trick to generate the name of a file to open. Note 
    // that it uses the PROC_ROOT variable
    char procfile[MAX_PATH_LENGTH + 1];
    char cmd[MAX_PATH_LENGTH + 1];
    char ** children[30];
    char 
    if (snprintf(procfile, MAX_PATH_LENGTH + 1, "%s/%d/exe", PROC_ROOT, pid) < 0) {
        fprintf(stderr, "snprintf failed to produce a filename\n");
        return 1;
    }
    printf("%s\n", procfile);
    
    if (snprintf(cmd, MAX_PATH_LENGTH + 1, "%s/%d/cmdline", PROC_ROOT, pid) < 0) {
        fprintf(stderr, "snprintf failed to produce a filename\n");
        return 1;
    }
    printf("%s\n", cmd);

    if (snprintf(procfile, MAX_PATH_LENGTH + 1, "%s/%d/task/%d/children", PROC_ROOT, pid, pid) < 0) {
        fprintf(stderr, "snprintf failed to produce a filename\n");
        return 1;
    }
    printf("%s\n", children);

    
    // Your implementation goes here.
    return 0;
}


/*
 * Prints the TreeNodes encountered on a preorder traversal of an PTree
 * to a specified maximum depth. If the maximum depth is 0, then the 
 * entire tree is printed.
 */
void print_ptree(struct TreeNode *root, int max_depth) {
    // Here's a trick for remembering what depth (in the tree) you're at
    // and printing 2 * that many spaces at the beginning of the line.
    static int depth = 0;
    printf("%*s", depth * 2, "");
    if(root != NULL){
	    printf("%d: ",root->pid);
	    printf("%s\n",root->name);
	}
    // Your implementation goes here.
//      if(*root){
  	 if(root->child_procs != NULL){
		depth++;
       		 print_ptree(root->child_procs, depth); 
	//	printf("depth is now: %d\n",depth);
	}
	 if (root->next_sibling != NULL){
      		  print_ptree(root->next_sibling, depth);
      }

//}
   
    
}
